<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Space Mining Sorting Game</title>

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000033;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            height: 100vh;
            /* Full viewport height */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid slice"><rect width="100" height="100" fill="%23000033"/><g fill="%23ffffff"><circle cx="10" cy="10" r="1"/><circle cx="30" cy="40" r="0.5"/><circle cx="50" cy="20" r="0.75"/><circle cx="70" cy="60" r="0.4"/><circle cx="90" cy="30" r="0.6"/></g></svg>');
            background-size: 300px 300px;
            animation: starsMove 60s linear infinite;
        }

        @keyframes starsMove {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 300px 300px;
            }
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 48px;
            display: none;
            text-align: center;
            text-shadow: 0 0 10px #FFD700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .box-label {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            width: 200px;
            text-shadow: 0 0 5px currentColor;
            transition: all 0.3s ease;
        }

        .box-label:hover {
            transform: scale(1.1);
        }

        #label-water {
            top: 25%;
            left: 25%;
            color: #00FFFF;
        }

        #label-iron {
            top: 25%;
            left: 75%;
            transform: translateX(-50%);
            color: #A9A9A9;
        }

        #label-gold {
            top: 75%;
            left: 25%;
            transform: translateY(-50%);
            color: #FFD700;
        }

        #label-uranium {
            top: 75%;
            left: 75%;
            transform: translate(-50%, -50%);
            color: #00FF00;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 33, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            transition: all 0.3s ease;
            opacity: 0.7;
            color: #FFD700;
        }

        #controls:hover {
            transform: scale(1.05);
            opacity: 1;
        }

        #funny-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FF69B4;
            font-size: 36px;
            text-align: center;
            opacity: 0;
            transition: opacity 2s;
            text-shadow: 0 0 10px #FF69B4;
        }

        #money-display {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #FFD700;
            font-size: 24px;
            background-color: rgba(0, 0, 33, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        #play-again-button {
            margin-top: 10px;
        }


        .speed-button {
            display: block;
            margin: 10px 0;
            padding: 12px 24px;
            width: 250px;
            text-align: center;
            background: transparent;
            color: #FFD700;
            border: 2px solid #FFD700;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .speed-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        .speed-button:disabled {
            background-color: transparent;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.5;
        }

        #random-delivery {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            /* background-color: #FF4500;
            color: white;
            border: none; */
            background: transparent;
            color: #FFD700;
            border: 2px solid #FFD700;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            opacity: 0.7;
        }

        #random-delivery:hover {
            /* background-color: #FF6347; */
            transform: translateX(-50%) scale(1.05);
            opacity: 1;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        #random-delivery:disabled {
            background-color: transparent;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.5;
        }

        /* Instructions Screen Styles */
        #instruction-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 51, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #FFFFFF;
            z-index: 9999;
        }

        #instruction-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #FFD700;
        }

        #instruction-screen p {
            font-size: 24px;
            max-width: 800px;
            text-align: center;
            margin-bottom: 40px;
        }

        #begin-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #FF4500;
            color: #FFFFFF;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.5);
            transition: all 0.3s ease;
        }

        #begin-button:hover {
            background-color: #FF6347;
            transform: scale(1.05);
        }

        /* Styles for Best Times List */
        #best-times {
            margin-top: 20px;
        }

        #best-times h2 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #FFD700;
        }

        /* Updated styles for the best times list */
        #best-times-list {
            list-style: none;
            padding: 0;
            font-size: 24px;
            display: flex;
            /* Use flexbox for horizontal layout */
            justify-content: center;
            /* Center the items */
            flex-wrap: wrap;
            /* Allow wrapping for responsiveness */
        }

        #best-times-list li {
            margin: 0 15px;
            /* Horizontal spacing between items */
            text-shadow: 0 0 5px #FFFFFF;
            margin-bottom: 0;
            /* Remove bottom margin */
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="message"></div>
    <div id="funny-message">Oops! The materials are escaping. Time for a space chase!</div>
    <div id="label-water" class="box-label">Water</div>
    <div id="label-iron" class="box-label">Iron Ore</div>
    <div id="label-gold" class="box-label">Gold</div>
    <div id="label-uranium" class="box-label">Uranium</div>
    <div id="controls">
        <button id="increase-speed" class="speed-button">Speed Increase (cost: 5) 0/5</button>
        <button id="buy-ship" class="speed-button">Buy New Ship (cost: 15) 1/10</button>
        <button id="buy-gravity-collector" class="speed-button" disabled>Buy Gravity Collector (Cost: 50)</button>
    </div>
    <div id="money-display">
        <div id="money-stats">
            Sorted Resources: 0<br>Total Resources Spent: 0
        </div>
        <!-- The Play Again button will be appended here -->
    </div>
    <button id="random-delivery" class="speed-button">Resources Delivery (cost 5 for 20) </button>

    <!-- Instructions Screen -->
    <div id="instruction-screen">
        <h1>Space Mining Sorting Game</h1>
        <p>Welcome to the Space Mining Sorting Game! Your mission is to sort different resources into their respective
            areas using your ships. Use the W,A,S,D keys to move your ship and the buttons to buy upgrades.
        <p>Get to 300 Sorted Resources to win. How quickly can you do it?</p>

        <!-- Best Times List -->
        <div id="best-times">
            <h2>Best Times:</h2>
            <ul id="best-times-list">
                <!-- Best times will be populated here -->
            </ul>
        </div>

        <button id="begin-button">Begin</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        document.addEventListener('touchmove', function (event) {
            event.preventDefault();
        }, { passive: false });

        // Prevent pinch zoom
        document.addEventListener('gesturestart', function (event) {
            event.preventDefault();
        });

        // Prevent zoom on double-tap
        var lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            var now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Prevent zoom on mouse wheel
        document.addEventListener('wheel', function (event) {
            if (event.ctrlKey) {
                event.preventDefault();
            }
        }, { passive: false });

        const { Engine, Render, World, Bodies, Body, Events } = Matter;

        let width = window.innerWidth;
        let height = window.innerHeight;

        const engine = Engine.create();
        engine.world.gravity.y = 0;
        const world = engine.world;

        const render = Render.create({
            element: document.body,
            canvas: document.getElementById('gameCanvas'),
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false,
                background: '#000033'
            }
        });

        Render.run(render);
        Engine.run(engine);

        // Create boundaries and add them to the world
        const boundaryThickness = 10;
        const boundaries = [
            Bodies.rectangle(width / 2, -boundaryThickness / 2, width, boundaryThickness, { isStatic: true }),
            Bodies.rectangle(width / 2, height + boundaryThickness / 2, width, boundaryThickness, { isStatic: true }),
            Bodies.rectangle(-boundaryThickness / 2, height / 2, boundaryThickness, height, { isStatic: true }),
            Bodies.rectangle(width + boundaryThickness / 2, height / 2, boundaryThickness, height, { isStatic: true }),
        ];
        World.add(world, boundaries);

        // Ship creation
        const shipVertices = [
            { x: 0, y: 0 },
            { x: 20, y: -10 },
            { x: 40, y: 0 },
            { x: 20, y: 10 }
        ];

        function createShip(x, y, color) {
            return Bodies.fromVertices(x, y, [shipVertices], {
                isStatic: false,
                render: {
                    fillStyle: color,
                    strokeStyle: '#FFFFFF',
                    lineWidth: 2
                }
            });
        }

        const automatedShips = [];
        let shipTargets = [];
        let automatedShipSpeed = 1;

        const ship1 = createShip(width / 2, height / 2, '#FF4500');
        automatedShips.push(ship1);
        shipTargets.push(null);

        // Ship purchase limit
        let shipsPurchased = 1; // Start with one ship
        const maxShips = 10;

        // Speed increase limit
        let speedIncreases = 0;
        const maxSpeedIncreases = 5;

        // Player-controlled ship
        function generateHexagon(radius) {
            const vertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                vertices.push({
                    x: radius * Math.cos(angle),
                    y: radius * Math.sin(angle)
                });
            }
            return vertices;
        }

        const ship3 = Bodies.fromVertices(width / 2 - 100, height / 2 - 100, [generateHexagon(23)], {
            isStatic: false,
            render: {
                fillStyle: '#32CD32',
                strokeStyle: '#228B22',
                lineWidth: 2
            }
        });

World.add(world, automatedShips.concat([ship3]));

        const materials = [
            { name: 'water', color: '#00FFFF' },
            { name: 'iron', color: '#A9A9A9' },
            { name: 'gold', color: '#FFD700' },
            { name: 'uranium', color: '#00FF00' }
        ];

        const circles = [];
        const circleRadius = 10;
        function generateCircles(count) {
            for (let i = 0; i < count; i++) {
                const material = materials[Math.floor(Math.random() * materials.length)];

                // Calculate a random offset to place circles near ship3 but not overlapping
                let offsetDistance = circleRadius * 8; // Minimum distance to avoid overlap
                let angle = Math.random() * Math.PI * 2; // Random angle
                let offsetX = Math.cos(angle) * offsetDistance;
                let offsetY = Math.sin(angle) * offsetDistance;

                let circleX = ship3.position.x + offsetX;
                let circleY = ship3.position.y + offsetY;

                // Ensure the circle is within the boundaries
                const margin = circleRadius + 20; // Margin from boundaries
                circleX = Math.min(Math.max(circleX, margin), width - margin);
                circleY = Math.min(Math.max(circleY, margin), height - margin);

                const circle = Bodies.circle(circleX, circleY, circleRadius, {
                    render: {
                        fillStyle: material.color,
                        strokeStyle: '#FFFFFF',
                        lineWidth: 2
                    },
                    collisionFilter: {
                        // Prevent the new circle from colliding with ship3
                        // mask: 0xFFFFFFFF ^ ship3.collisionFilter.category
                    }
                });

                circle.isTargeted = false; // Initialize isTargeted flag
                World.add(world, circle);
                circles.push(circle);

                // Create a ghost circle ring for the visual effect
                setTimeout(() => {
                    createGhostRing(circle.position.x, circle.position.y);
                }, 50);
            }
        }

        function createGhostRing(x, y) {
            const initialRadius = 10; // Start small and grow
            const ghostRing = Bodies.circle(x, y, initialRadius, {
                isStatic: true,  // Ghost circle should not interact with physics
                render: {
                    fillStyle: 'transparent',  // No fill, just a ring
                    strokeStyle: '#FFFF00',    // Yellow ring
                    lineWidth: 5,              // Thickness of the ring
                    opacity: 1
                },
                collisionFilter: {
                    group: -1,  // Ensure it does not collide with anything
                    category: 0x0001,
                    mask: 0x0000  // No collisions with other objects
                }
            });

            World.add(world, ghostRing);

            // Animate growing and fading out
            let growInterval = setInterval(() => {
                ghostRing.circleRadius *= 1.1;  // Increase the size of the ring
                ghostRing.render.opacity *= 0.9; // Fade out the opacity

                if (ghostRing.render.opacity < 0.1) {
                    World.remove(world, ghostRing); // Remove the ghost ring once it's nearly invisible
                    clearInterval(growInterval);   // Stop the interval once it's removed
                }
            }, 50); // Adjust speed of growing and fading
        }

        generateCircles(25);

        const targetPositions = {
            'water': { x: width / 4, y: height / 4 },
            'iron': { x: (3 * width) / 4, y: height / 4 },
            'gold': { x: width / 4, y: (3 * height) / 4 },
            'uranium': { x: (3 * width) / 4, y: (3 * height) / 4 },
        };

        let money = 0;
        let totalMoneySpent = 0;

        function updateMoney() {
            let elapsedTime = '';
            if (startTime) {
                elapsedTime = formatElapsedTime(startTime);
            } else {
                elapsedTime = '00:00';
            }

            document.getElementById('money-stats').innerHTML = `Sorted Resources: ${money}
    <br>Total Resources Spent: ${totalMoneySpent}
    <br>Total Unsorted: ${circles.length - money}
    <br>Time Elapsed: ${elapsedTime}`;
            updateButtons();
        }

        function updateButtons() {
            const increaseSpeedButton = document.getElementById('increase-speed');
            const buyShipButton = document.getElementById('buy-ship');
            const buyGravityCollectorButton = document.getElementById('buy-gravity-collector');
            const randomDeliveryButton = document.getElementById('random-delivery');

            increaseSpeedButton.disabled = money < 5 || speedIncreases >= maxSpeedIncreases;
            buyShipButton.disabled = money < 15 || shipsPurchased >= maxShips;
            buyGravityCollectorButton.disabled = money < 50;
            randomDeliveryButton.disabled = money < 5 || circles.length >= 300;

            // Update button text with counts
            increaseSpeedButton.innerHTML = `Speed Increase (cost: 5) ${speedIncreases}/${maxSpeedIncreases}`;
            buyShipButton.innerHTML = `Buy New Ship (cost: 15) ${shipsPurchased}/${maxShips}`;
        }

        document.getElementById('buy-gravity-collector').addEventListener('click', () => {
            const cost = 50;
            if (money >= cost) {
                money -= cost;
                totalMoneySpent += cost;
                updateMoney();
                activateGravityCollector();
            }
        });

        document.getElementById('increase-speed').addEventListener('click', () => {
            if (money >= 5 && speedIncreases < maxSpeedIncreases) {
                money -= 5;
                totalMoneySpent += 5;
                automatedShipSpeed += 0.25;
                speedIncreases += 1;
                removeSortedCircles(5);
                updateMoney();

                if (speedIncreases >= maxSpeedIncreases) {
                    document.getElementById('increase-speed').disabled = true;
                }
            }
        });

        function getRandomColor() {
            const colors = ['#FF4500', '#4169E1', '#FFD700', '#00FF00', '#FF69B4'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        document.getElementById('buy-ship').addEventListener('click', () => {
            const cost = 15;
            if (money >= cost && shipsPurchased < maxShips) {
                money -= cost;
                totalMoneySpent += cost;
                removeSortedCircles(15);
                const newShip = createShip(width / 2, height / 2, getRandomColor());
                automatedShips.push(newShip);
                shipTargets.push(null);
                World.add(world, newShip);
                shipsPurchased += 1;
                updateMoney();

                if (shipsPurchased >= maxShips) {
                    document.getElementById('buy-ship').disabled = true;
                }
            }
        });

        document.getElementById('random-delivery').addEventListener('click', () => {
            if (money >= 5 && circles.length < 300) {
                removeSortedCircles(5);
                money -= 5;
                totalMoneySpent += 5;
                generateCircles(20);
                updateMoney();
            }
        });

        function moveShipTowards(ship, targetX, targetY, speed) {
            const angle = Math.atan2(targetY - ship.position.y, targetX - ship.position.x);

            const velocityX = Math.cos(angle) * speed;
            const velocityY = Math.sin(angle) * speed;

            Body.setVelocity(ship, { x: velocityX, y: velocityY });
            Body.setAngle(ship, angle);
        }

        function pushCircleTowards(circle, targetX, targetY) {
            const angle = Math.atan2(targetY - circle.position.y, targetX - circle.position.x);
            const pushSpeed = 2;

            const velocityX = Math.cos(angle) * pushSpeed;
            const velocityY = Math.sin(angle) * pushSpeed;

            Body.setVelocity(circle, { x: velocityX, y: velocityY });
        }

        function isCircleInCorrectArea(circle, tolerance_starting = 200) {
            const { x, y } = circle.position;
            const material = materials.find(m => m.color === circle.render.fillStyle);
            const target = targetPositions[material.name];

            const tolerance = tolerance_starting;
            const distance = Math.hypot(x - target.x, y - target.y);

            if (distance <= tolerance) {
                circle.isTargeted = false;
                return true;
            }

            return false;
        }

        function updateAutomation() {
            if (circles.length < 10) {
                generateCircles(1)
            }

            for (let i = 0; i < automatedShips.length; i++) {
                const ship = automatedShips[i];
                let currentTarget = shipTargets[i];

                if (currentTarget && isCircleInCorrectArea(currentTarget)) {
                    currentTarget.isTargeted = false;
                    shipTargets[i] = null;
                    currentTarget = null;
                }

                if (!currentTarget || currentTarget.isTargeted === false) {
                    let nearestCircle = null;
                    let shortestDistance = Infinity;

                    for (let j = 0; j < circles.length; j++) {
                        const circle = circles[j];
                        if (!circle.isTargeted && !isCircleInCorrectArea(circle)) {
                            const distance = Math.hypot(circle.position.x - ship.position.x, circle.position.y - ship.position.y);

                            if (distance < shortestDistance) {
                                shortestDistance = distance;
                                nearestCircle = circle;
                            }
                        }
                    }

                    if (nearestCircle) {
                        shipTargets[i] = nearestCircle;
                        nearestCircle.isTargeted = true;
                    }
                }

                if (shipTargets[i]) {
                    const circle = shipTargets[i];
                    const { x: circleX, y: circleY } = circle.position;
                    const material = materials.find(m => m.color === circle.render.fillStyle);
                    const target = targetPositions[material.name];

                    const distanceToTarget = Math.hypot(circleX - target.x, circleY - target.y);

                    if (distanceToTarget < 50) {
                        // Circle is near its target
                    } else {
                        const distanceToCircle = Math.hypot(circle.position.x - ship.position.x, circle.position.y - ship.position.y);

                        if (distanceToCircle < 30) {
                            pushCircleTowards(circle, target.x, target.y);
                        } else {
                            moveShipTowards(ship, circle.position.x, circle.position.y, automatedShipSpeed);
                        }
                    }
                }
            }
        }

        let gameWon = false;
        let funnyMessageTimeout = null;
        let startTime = null;

        function formatElapsedTime(startTime) {
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000);

            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            const formattedMinutes = minutes.toString().padStart(2, '0');
            const formattedSeconds = seconds.toString().padStart(2, '0');

            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function formatTimeFromSeconds(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;

            const formattedMinutes = minutes.toString().padStart(2, '0');
            const formattedSeconds = seconds.toString().padStart(2, '0');

            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function checkWinCondition() {
            let allCirclesCorrect = true;
            money = 0;

            for (let i = 0; i < circles.length; i++) {
                const circle = circles[i];
                if (isCircleInCorrectArea(circle)) {
                    money++;
                } else {
                    allCirclesCorrect = false;
                }
            }

            updateMoney();

            if (allCirclesCorrect && !gameWon && circles.length >= 300) {
                let message = document.getElementById('message')
                message.style.display = 'block';

                // Get the elapsed time in seconds
                const now = new Date();
                const elapsedTimeInSeconds = Math.floor((now - startTime) / 1000);

                const elapsedTimeFormatted = formatElapsedTime(startTime);
                message.innerHTML = `Congratulations, you have fully sorted ${circles.length} resources in ${elapsedTimeFormatted}`
                gameWon = true;

                // Store the time taken to win in localStorage
                storeBestTime(elapsedTimeInSeconds);

                // Show 'Play Again' button
                showPlayAgainButton();

            } else if (!allCirclesCorrect && gameWon) {
                gameWon = false;
                document.getElementById('message').style.display = 'none';
                showFunnyMessage();
            }
        }

        // Function to store the best time in localStorage
        function storeBestTime(timeInSeconds) {
            // Get the existing times from localStorage
            let bestTimes = localStorage.getItem('bestTimes');

            if (bestTimes) {
                bestTimes = JSON.parse(bestTimes);
            } else {
                bestTimes = [];
            }

            // Add the new time
            bestTimes.push(timeInSeconds);

            // Sort the times in ascending order
            bestTimes.sort(function (a, b) {
                return a - b;
            });

            // Keep only the top 5 times
            if (bestTimes.length > 5) {
                bestTimes = bestTimes.slice(0, 5);
            }

            // Store back to localStorage
            localStorage.setItem('bestTimes', JSON.stringify(bestTimes));
        }

        function showPlayAgainButton() {
            const moneyDisplay = document.getElementById('money-display');
            // Check if the button already exists to prevent duplicates
            if (!document.getElementById('play-again-button')) {
                const playAgainButton = document.createElement('button');
                playAgainButton.id = 'play-again-button';
                playAgainButton.innerHTML = 'Play Again';
                playAgainButton.className = 'speed-button';
                playAgainButton.style.marginTop = '10px';
                playAgainButton.addEventListener('click', function () {
                    location.reload();
                });

                moneyDisplay.appendChild(playAgainButton);
            }
        }


        // Function to display best times on the instruction screen
        function displayBestTimes() {
            let bestTimes = localStorage.getItem('bestTimes');

            if (bestTimes) {
                bestTimes = JSON.parse(bestTimes);
            } else {
                bestTimes = [];
            }

            const bestTimesList = document.getElementById('best-times-list');
            bestTimesList.innerHTML = ''; // Clear any existing list items

            for (let i = 0; i < bestTimes.length; i++) {
                const timeInSeconds = bestTimes[i];
                const formattedTime = formatTimeFromSeconds(timeInSeconds);
                const listItem = document.createElement('li');
                listItem.innerText = `${i + 1}. ${formattedTime}`;
                bestTimesList.appendChild(listItem);
            }
        }

        function showFunnyMessage() {
            const funnyMessage = document.getElementById('funny-message');
            funnyMessage.style.opacity = '1';

            if (funnyMessageTimeout) {
                clearTimeout(funnyMessageTimeout);
            }

            funnyMessageTimeout = setTimeout(() => {
                funnyMessage.style.opacity = '0';
            }, 3000);
        }

        // Ship3 (controlled by WASD keys)
        const wasdKeys = { w: false, s: false, a: false, d: false };

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW') wasdKeys.w = true;
            if (e.code === 'KeyS') wasdKeys.s = true;
            if (e.code === 'KeyA') wasdKeys.a = true;
            if (e.code === 'KeyD') wasdKeys.d = true;
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') wasdKeys.w = false;
            if (e.code === 'KeyS') wasdKeys.s = false;
            if (e.code === 'KeyA') wasdKeys.a = false;
            if (e.code === 'KeyD') wasdKeys.d = false;
        });

        function controlShip3() {
            const speed = 2;
            let velocity = { x: 0, y: 0 };

            if (wasdKeys.w) velocity.y -= speed;
            if (wasdKeys.s) velocity.y += speed;
            if (wasdKeys.a) velocity.x -= speed;
            if (wasdKeys.d) velocity.x += speed;

            Body.setVelocity(ship3, velocity);
        }

        let gravityCollectorPurchased = false;
        let gravityCollectorStrength = 1;

        function removeSortedCircles(numToRemove) {
            let removedCount = 0;
            totalMoneySpent += numToRemove;

            for (let i = circles.length - 1; i >= 0 && removedCount < numToRemove; i--) {
                if (isCircleInCorrectArea(circles[i])) {
                    const circle = circles[i];
                    circle.isTargeted = false;
                    const circlePosition = { x: circle.position.x, y: circle.position.y };
                    const circleColor = circle.render.fillStyle;

                    World.remove(world, circle);
                    circles.splice(i, 1);
                    removedCount++;

                    // Create a "ghost" circle for the visual effect
                    const ghostCircle = Bodies.circle(circlePosition.x, circlePosition.y, circle.circleRadius * 1.2, {
                        isStatic: true,
                        collisionFilter: {
                            group: -1,
                            category: 0x0001,
                            mask: 0x0000
                        },
                        render: {
                            fillStyle: circleColor,
                            opacity: 1
                        }
                    });

                    World.add(world, ghostCircle);

                    let fadeInterval = setInterval(() => {
                        ghostCircle.circleRadius *= 0.9;
                        ghostCircle.render.opacity *= 0.9;
                        if (ghostCircle.circleRadius < 1 || ghostCircle.render.opacity < 0.1) {
                            World.remove(world, ghostCircle);
                            clearInterval(fadeInterval);
                        }
                    }, 200);
                }
            }
        }

        function addRedRings() {
            const ringOptions = {
                isStatic: true,
                render: {
                    fillStyle: 'transparent',
                    strokeStyle: 'rgba(255, 0, 0, 0.3)', // Faint red color with 30% opacity
                    lineWidth: 5,
                    opacity: 1
                },
                collisionFilter: {
                    group: -1, // Ensure it does not collide with anything
                    category: 0x0001,
                    mask: 0x0000 // No collisions with other objects
                }
            };

            // Define the radius of the rings
            const ringRadius = 150; // Adjust as needed for visual effect

            // Create and add rings for each target position
            for (let key in targetPositions) {
                const pos = targetPositions[key];
                const ring = Bodies.circle(pos.x, pos.y, ringRadius, ringOptions);
                World.add(world, ring);
            }
        }

        function activateGravityCollector() {
            removeSortedCircles(50);
            if (gravityCollectorPurchased) {
                gravityCollectorStrength += 1;
                document.getElementById("buy-gravity-collector").innerHTML = `Upgrade Gravity Collector to level ${gravityCollectorStrength + 1} (cost 50)`;
                return;
            }
            gravityCollectorPurchased = true;
            document.getElementById("buy-gravity-collector").innerHTML = `Upgrade Gravity Collector to level ${gravityCollectorStrength + 1} (cost 50)`;
            addRedRings()
            Events.on(engine, 'beforeUpdate', function () {
                if (gravityCollectorPurchased) {
                    circles.forEach(circle => {
                        if (!isCircleInCorrectArea(circle, tolerance_starting = 100)) {
                            const material = materials.find(m => m.color === circle.render.fillStyle);
                            const target = targetPositions[material.name];
                            const angle = Math.atan2(target.y - circle.position.y, target.x - circle.position.x);

                            Body.applyForce(circle, circle.position, {
                                x: 0.0000005 * gravityCollectorStrength * Math.cos(angle),
                                y: 0.0000005 * gravityCollectorStrength * Math.sin(angle)
                            });
                        }
                    });
                }
            });
        }

        // Start the game loop
        let gameStarted = false;

        (function run() {
            window.requestAnimationFrame(run);
            if (gameStarted) {
                Engine.update(engine, 1000 / 60);
                controlShip3();
                updateAutomation();
                checkWinCondition();
            }
        })();

        // Display best times when the instruction screen is shown
        displayBestTimes();

        // Handle Begin button click
        document.getElementById('begin-button').addEventListener('click', () => {
            document.getElementById('instruction-screen').style.display = 'none';
            gameStarted = true;
            startTime = new Date();
        });
    </script>
</body>

</html>