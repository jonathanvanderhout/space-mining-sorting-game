<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Space Mining Sorting Game</title>

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000033;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            height: 100vh;
            /* Full viewport height */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 48px;
            display: none;
            text-align: center;
            text-shadow: 0 0 10px #FFD700;
            animation: pulse 2s infinite;
            z-index: 999;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        #funny-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FF69B4;
            font-size: 36px;
            text-align: center;
            opacity: 0;
            transition: opacity 2s;
            text-shadow: 0 0 10px #FF69B4;
            z-index: 999;
        }

        .box-label {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            width: 200px;
            text-shadow: 0 0 5px currentColor;
            transition: all 0.3s ease;
            z-index: 999;
        }

        .box-label:hover {
            transform: scale(1.1);
        }

        #label-water {
            top: 25%;
            left: 25%;
            color: #00FFFF;
        }

        #label-iron {
            top: 25%;
            left: 75%;
            transform: translateX(-50%);
            color: #A9A9A9;
        }

        #label-gold {
            top: 75%;
            left: 25%;
            transform: translateY(-50%);
            color: #FFD700;
        }

        #label-uranium {
            top: 75%;
            left: 75%;
            transform: translate(-50%, -50%);
            color: #00FF00;
        }

        /* Admin Panel Styles */
        #admin-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background-color: rgba(0, 0, 33, 0.95);
            padding: 20px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            transition: transform 0.3s ease;
            transform: translateX(0);
            color: #FFD700;
            z-index: 1000;
        }

        #admin-panel.collapsed {
            transform: translateX(100%);
        }

        #admin-panel-toggle {
            position: fixed;
            top: 0;
            right: 0;
            background-color: rgba(0, 0, 33, 0.9);
            color: #FFD700;
            border: none;
            padding: 10px;
            cursor: pointer;
            z-index: 1001;
            border-radius: 10px 0 0 10px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
        }

        #admin-panel .section {
            margin-bottom: 20px;
        }

        #admin-panel h2 {
            margin-top: 0;
            font-size: 24px;
            text-shadow: 0 0 5px #FFD700;
        }

        #money-display {
            color: #FFD700;
            font-size: 18px;
        }

        /* Custom Scrollbar Styles */
        #admin-panel::-webkit-scrollbar {
            width: 12px;
        }

        #admin-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 33, 0.9);
        }

        #admin-panel::-webkit-scrollbar-thumb {
            background-color: #FFD700;
            border-radius: 6px;
            border: 3px solid rgba(0, 0, 33, 0.9);
        }

        #admin-panel {
            scrollbar-width: thin;
            scrollbar-color: #FFD700 rgba(0, 0, 33, 0.9);
        }

        /* Button Styles */
        .speed-button {
            display: block;
            margin: 10px 0;
            padding: 12px 24px;
            width: 100%;
            text-align: center;
            background: transparent;
            color: #FFD700;
            border: 2px solid #FFD700;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .speed-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        .speed-button:disabled {
            background-color: transparent;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.5;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="message"></div>
    <div id="funny-message">Oops! The materials are escaping. Time for a space chase!</div>
    <div id="label-water" class="box-label">Water</div>
    <div id="label-iron" class="box-label">Iron Ore</div>
    <div id="label-gold" class="box-label">Gold</div>
    <div id="label-uranium" class="box-label">Uranium</div>

    <!-- Admin Panel Toggle Button -->
    <button id="admin-panel-toggle">â˜°</button>

    <!-- Admin Panel -->
    <div id="admin-panel">
        <div class="section">
            <h2>Game Stats</h2>
            <div id="money-display">
                <div id="money-stats">
                    Sorted Resources: 0<br>Total Resources Spent: 0
                </div>
                <!-- The Play Again button will be appended here -->
            </div>
        </div>
        <div class="section">
            <h2>Controls</h2>
            <button id="increase-speed" class="speed-button">Speed Increase (cost: 5) 0/5</button>
            <button id="buy-ship" class="speed-button">Buy New Ship (cost: 15) 1/10</button>
            <button id="buy-gravity-collector" class="speed-button" disabled>Buy Gravity Collector (Cost: 50)</button>
            <button id="random-delivery" class="speed-button">Resources Delivery (cost 5 for 20)</button>
        </div>
    </div>

    <!-- Include the script for Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>

    <!-- Game Script -->
    <script>
        // Prevent default touch actions and zooming
        document.addEventListener('touchmove', function (event) {
            event.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturestart', function (event) {
            event.preventDefault();
        });

        var lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            var now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        document.addEventListener('wheel', function (event) {
            if (event.ctrlKey) {
                event.preventDefault();
            }
        }, { passive: false });

        const { Engine, Render, World, Bodies, Body, Events } = Matter;

        // Define fixed game world size
        const GAME_WIDTH = 1920;
        const GAME_HEIGHT = 1080;

        // Calculate scaling factor based on window size
        let scaleX = window.innerWidth / GAME_WIDTH;
        let scaleY = window.innerHeight / GAME_HEIGHT;
        let scale = Math.min(scaleX, scaleY);

        const engine = Engine.create();
        engine.world.gravity.y = 0;
        const world = engine.world;

        const render = Render.create({
            element: document.body,
            canvas: document.getElementById('gameCanvas'),
            engine: engine,
            options: {
                width: GAME_WIDTH * scale,
                height: GAME_HEIGHT * scale,
                wireframes: false,
                background: '#000033',
                hasBounds: true,
                showBounds: false,
                pixelRatio: 1 / scale, // Adjust pixel ratio to scale graphics
            }
        });

        // Adjust renderer bounds to simulate scaling
        render.bounds.max.x = GAME_WIDTH;
        render.bounds.max.y = GAME_HEIGHT;
        render.bounds.min.x = 0;
        render.bounds.min.y = 0;

        // Adjust the canvas style to fit the window
        render.canvas.style.width = `${GAME_WIDTH * scale}px`;
        render.canvas.style.height = `${GAME_HEIGHT * scale}px`;

        Render.run(render);
        Engine.run(engine);

        // Create boundaries and add them to the world
        const boundaryThickness = 10;
        const boundaries = [
            Bodies.rectangle(GAME_WIDTH / 2, -boundaryThickness / 2, GAME_WIDTH, boundaryThickness, { isStatic: true }),
            Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + boundaryThickness / 2, GAME_WIDTH, boundaryThickness, { isStatic: true }),
            Bodies.rectangle(-boundaryThickness / 2, GAME_HEIGHT / 2, boundaryThickness, GAME_HEIGHT, { isStatic: true }),
            Bodies.rectangle(GAME_WIDTH + boundaryThickness / 2, GAME_HEIGHT / 2, boundaryThickness, GAME_HEIGHT, { isStatic: true }),
        ];
        World.add(world, boundaries);

        // Ship creation
        const shipVertices = [
            { x: 0, y: 0 },
            { x: 20, y: -10 },
            { x: 40, y: 0 },
            { x: 20, y: 10 }
        ];

        function createShip(x, y, color) {
            return Bodies.fromVertices(x, y, [shipVertices], {
                isStatic: false,
                render: {
                    fillStyle: color,
                    strokeStyle: '#FFFFFF',
                    lineWidth: 2
                }
            });
        }

        const automatedShips = [];
        let shipTargets = [];
        let automatedShipSpeed = 1;

        const ship1 = createShip(GAME_WIDTH / 2, GAME_HEIGHT / 2, '#FF4500');
        automatedShips.push(ship1);
        shipTargets.push(null);

        // Ship purchase limit
        let shipsPurchased = 1; // Start with one ship
        const maxShips = 10;

        // Speed increase limit
        let speedIncreases = 0;
        const maxSpeedIncreases = 5;

        // Player-controlled ship
        function generateHexagon(radius) {
            const vertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                vertices.push({
                    x: radius * Math.cos(angle),
                    y: radius * Math.sin(angle)
                });
            }
            return vertices;
        }

        const ship3 = Bodies.fromVertices(GAME_WIDTH / 2 - 100, GAME_HEIGHT / 2 - 100, [generateHexagon(23)], {
            isStatic: false,
            render: {
                fillStyle: '#32CD32',
                strokeStyle: '#228B22',
                lineWidth: 2
            }
        });

        World.add(world, automatedShips.concat([ship3]));

        const materials = [
            { name: 'water', color: '#00FFFF' },
            { name: 'iron', color: '#A9A9A9' },
            { name: 'gold', color: '#FFD700' },
            { name: 'uranium', color: '#00FF00' }
        ];

        const circles = [];
        const circleRadius = 10;
        function generateCircles(count) {
            for (let i = 0; i < count; i++) {
                const material = materials[Math.floor(Math.random() * materials.length)];

                // Calculate a random offset to place circles near ship3 but not overlapping
                let offsetDistance = circleRadius * 8; // Minimum distance to avoid overlap
                let angle = Math.random() * Math.PI * 2; // Random angle
                let offsetX = Math.cos(angle) * offsetDistance;
                let offsetY = Math.sin(angle) * offsetDistance;

                let circleX = ship3.position.x + offsetX;
                let circleY = ship3.position.y + offsetY;

                // Ensure the circle is within the boundaries
                const margin = circleRadius + 20; // Margin from boundaries
                circleX = Math.min(Math.max(circleX, margin), GAME_WIDTH - margin);
                circleY = Math.min(Math.max(circleY, margin), GAME_HEIGHT - margin);

                const circle = Bodies.circle(circleX, circleY, circleRadius, {
                    render: {
                        fillStyle: material.color,
                        strokeStyle: '#FFFFFF',
                        lineWidth: 2
                    },
                    collisionFilter: {
                        // Prevent the new circle from colliding with ship3
                        // mask: 0xFFFFFFFF ^ ship3.collisionFilter.category
                    }
                });

                circle.isTargeted = false; // Initialize isTargeted flag
                World.add(world, circle);
                circles.push(circle);

                // Create a ghost ring for the visual effect
                setTimeout(() => {
                    createGhostRing(circle.position.x, circle.position.y);
                }, 50);
            }
        }

        function createGhostRing(x, y) {
            const initialRadius = 10; // Start small and grow
            const ghostRing = Bodies.circle(x, y, initialRadius, {
                isStatic: true,  // Ghost circle should not interact with physics
                render: {
                    fillStyle: 'transparent',  // No fill, just a ring
                    strokeStyle: '#FFFF00',    // Yellow ring
                    lineWidth: 5,              // Thickness of the ring
                    opacity: 1
                },
                collisionFilter: {
                    group: -1,  // Ensure it does not collide with anything
                    category: 0x0001,
                    mask: 0x0000  // No collisions with other objects
                }
            });

            World.add(world, ghostRing);

            // Animate growing and fading out
            let growInterval = setInterval(() => {
                ghostRing.circleRadius *= 1.1;  // Increase the size of the ring
                ghostRing.render.opacity *= 0.9; // Fade out the opacity

                if (ghostRing.render.opacity < 0.1) {
                    World.remove(world, ghostRing); // Remove the ghost ring once it's nearly invisible
                    clearInterval(growInterval);   // Stop the interval once it's removed
                }
            }, 50); // Adjust speed of growing and fading
        }

        generateCircles(25);

        const targetPositions = {
            'water': { x: GAME_WIDTH / 4, y: GAME_HEIGHT / 4 },
            'iron': { x: (3 * GAME_WIDTH) / 4, y: GAME_HEIGHT / 4 },
            'gold': { x: GAME_WIDTH / 4, y: (3 * GAME_HEIGHT) / 4 },
            'uranium': { x: (3 * GAME_WIDTH) / 4, y: (3 * GAME_HEIGHT) / 4 },
        };

        let money = 0;
        let totalMoneySpent = 0;

        function updateMoney() {
            let elapsedTime = '';
            if (startTime) {
                elapsedTime = formatElapsedTime(startTime);
            } else {
                elapsedTime = '00:00';
            }

            document.getElementById('money-stats').innerHTML = `Sorted Resources: ${money}
    <br>Total Resources Spent: ${totalMoneySpent}
    <br>Total Unsorted: ${circles.length - money}
    <br>Time Elapsed: ${elapsedTime}`;
            updateButtons();
        }

        function updateButtons() {
            const increaseSpeedButton = document.getElementById('increase-speed');
            const buyShipButton = document.getElementById('buy-ship');
            const buyGravityCollectorButton = document.getElementById('buy-gravity-collector');
            const randomDeliveryButton = document.getElementById('random-delivery');

            increaseSpeedButton.disabled = money < 5 || speedIncreases >= maxSpeedIncreases;
            buyShipButton.disabled = money < 15 || shipsPurchased >= maxShips;
            buyGravityCollectorButton.disabled = money < 50;
            randomDeliveryButton.disabled = money < 5 || circles.length >= 300;

            // Update button text with counts
            increaseSpeedButton.innerHTML = `Speed Increase (cost: 5) ${speedIncreases}/${maxSpeedIncreases}`;
            buyShipButton.innerHTML = `Buy New Ship (cost: 15) ${shipsPurchased}/${maxShips}`;
        }

        document.getElementById('buy-gravity-collector').addEventListener('click', () => {
            const cost = 50;
            if (money >= cost) {
                money -= cost;
                totalMoneySpent += cost;
                updateMoney();
                activateGravityCollector();
            }
        });

        document.getElementById('increase-speed').addEventListener('click', () => {
            if (money >= 5 && speedIncreases < maxSpeedIncreases) {
                money -= 5;
                totalMoneySpent += 5;
                automatedShipSpeed += 0.25;
                speedIncreases += 1;
                removeSortedCircles(5);
                updateMoney();

                if (speedIncreases >= maxSpeedIncreases) {
                    document.getElementById('increase-speed').disabled = true;
                }
            }
        });

        function getRandomColor() {
            const colors = ['#FF4500', '#4169E1', '#FFD700', '#00FF00', '#FF69B4'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        document.getElementById('buy-ship').addEventListener('click', () => {
            const cost = 15;
            if (money >= cost && shipsPurchased < maxShips) {
                money -= cost;
                totalMoneySpent += cost;
                removeSortedCircles(15);
                const newShip = createShip(GAME_WIDTH / 2, GAME_HEIGHT / 2, getRandomColor());
                automatedShips.push(newShip);
                shipTargets.push(null);
                World.add(world, newShip);
                shipsPurchased += 1;
                updateMoney();

                if (shipsPurchased >= maxShips) {
                    document.getElementById('buy-ship').disabled = true;
                }
            }
        });

        document.getElementById('random-delivery').addEventListener('click', () => {
            if (money >= 5 && circles.length < 300) {
                removeSortedCircles(5);
                money -= 5;
                totalMoneySpent += 5;
                generateCircles(20);
                updateMoney();
            }
        });

        function moveShipTowards(ship, targetX, targetY, speed) {
            const angle = Math.atan2(targetY - ship.position.y, targetX - ship.position.x);

            const velocityX = Math.cos(angle) * speed;
            const velocityY = Math.sin(angle) * speed;

            Body.setVelocity(ship, { x: velocityX, y: velocityY });
            Body.setAngle(ship, angle);
        }

        function pushCircleTowards(circle, targetX, targetY) {
            const angle = Math.atan2(targetY - circle.position.y, targetX - circle.position.x);
            const pushSpeed = 2;

            const velocityX = Math.cos(angle) * pushSpeed;
            const velocityY = Math.sin(angle) * pushSpeed;

            Body.setVelocity(circle, { x: velocityX, y: velocityY });
        }

        function isCircleInCorrectArea(circle, tolerance_starting = 200) {
            const { x, y } = circle.position;
            const material = materials.find(m => m.color === circle.render.fillStyle);
            const target = targetPositions[material.name];

            const tolerance = tolerance_starting;
            const distance = Math.hypot(x - target.x, y - target.y);

            if (distance <= tolerance) {
                circle.isTargeted = false;
                return true;
            }

            return false;
        }

        function updateAutomation() {
            if (circles.length < 10) {
                generateCircles(1)
            }

            for (let i = 0; i < automatedShips.length; i++) {
                const ship = automatedShips[i];
                let currentTarget = shipTargets[i];

                if (currentTarget && isCircleInCorrectArea(currentTarget)) {
                    currentTarget.isTargeted = false;
                    shipTargets[i] = null;
                    currentTarget = null;
                }

                if (!currentTarget || currentTarget.isTargeted === false) {
                    let nearestCircle = null;
                    let shortestDistance = Infinity;

                    for (let j = 0; j < circles.length; j++) {
                        const circle = circles[j];
                        if (!circle.isTargeted && !isCircleInCorrectArea(circle)) {
                            const distance = Math.hypot(circle.position.x - ship.position.x, circle.position.y - ship.position.y);

                            if (distance < shortestDistance) {
                                shortestDistance = distance;
                                nearestCircle = circle;
                            }
                        }
                    }

                    if (nearestCircle) {
                        shipTargets[i] = nearestCircle;
                        nearestCircle.isTargeted = true;
                    }
                }

                if (shipTargets[i]) {
                    const circle = shipTargets[i];
                    const { x: circleX, y: circleY } = circle.position;
                    const material = materials.find(m => m.color === circle.render.fillStyle);
                    const target = targetPositions[material.name];

                    const distanceToTarget = Math.hypot(circleX - target.x, circleY - target.y);

                    if (distanceToTarget < 50) {
                        // Circle is near its target
                    } else {
                        const distanceToCircle = Math.hypot(circle.position.x - ship.position.x, circle.position.y - ship.position.y);

                        if (distanceToCircle < 30) {
                            pushCircleTowards(circle, target.x, target.y);
                        } else {
                            moveShipTowards(ship, circle.position.x, circle.position.y, automatedShipSpeed);
                        }
                    }
                }
            }
        }

        let gameWon = false;
        let funnyMessageTimeout = null;
        let startTime = null;

        function formatElapsedTime(startTime) {
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000);

            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            const formattedMinutes = minutes.toString().padStart(2, '0');
            const formattedSeconds = seconds.toString().padStart(2, '0');

            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function formatTimeFromSeconds(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;

            const formattedMinutes = minutes.toString().padStart(2, '0');
            const formattedSeconds = seconds.toString().padStart(2, '0');

            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function checkWinCondition() {
            let allCirclesCorrect = true;
            money = 0;

            for (let i = 0; i < circles.length; i++) {
                const circle = circles[i];
                if (isCircleInCorrectArea(circle)) {
                    money++;
                } else {
                    allCirclesCorrect = false;
                }
            }

            updateMoney();

            if (allCirclesCorrect && !gameWon && circles.length >= 300) {
                let message = document.getElementById('message')
                message.style.display = 'block';

                // Get the elapsed time in seconds
                const now = new Date();
                const elapsedTimeInSeconds = Math.floor((now - startTime) / 1000);

                const elapsedTimeFormatted = formatElapsedTime(startTime);
                message.innerHTML = `Congratulations, you have fully sorted ${circles.length} resources in ${elapsedTimeFormatted}`
                gameWon = true;

                // Store the time taken to win in localStorage
                storeBestTime(elapsedTimeInSeconds);

                // Show 'Play Again' button
                showPlayAgainButton();

            } else if (!allCirclesCorrect && gameWon) {
                gameWon = false;
                document.getElementById('message').style.display = 'none';
                showFunnyMessage();
            }
        }

        // Function to store the best time in localStorage
        function storeBestTime(timeInSeconds) {
            // Get the existing times from localStorage
            let bestTimes = localStorage.getItem('bestTimes');

            if (bestTimes) {
                bestTimes = JSON.parse(bestTimes);
            } else {
                bestTimes = [];
            }

            // Add the new time
            bestTimes.push(timeInSeconds);

            // Sort the times in ascending order
            bestTimes.sort(function (a, b) {
                return a - b;
            });

            // Keep only the top 5 times
            if (bestTimes.length > 5) {
                bestTimes = bestTimes.slice(0, 5);
            }

            // Store back to localStorage
            localStorage.setItem('bestTimes', JSON.stringify(bestTimes));
        }

        function showPlayAgainButton() {
            const moneyDisplay = document.getElementById('money-display');
            // Check if the button already exists to prevent duplicates
            if (!document.getElementById('play-again-button')) {
                const playAgainButton = document.createElement('button');
                playAgainButton.id = 'play-again-button';
                playAgainButton.innerHTML = 'Play Again';
                playAgainButton.className = 'speed-button';
                playAgainButton.style.marginTop = '10px';
                playAgainButton.addEventListener('click', function () {
                    location.reload();
                });

                moneyDisplay.appendChild(playAgainButton);
            }
        }

        function showFunnyMessage() {
            const funnyMessage = document.getElementById('funny-message');
            funnyMessage.style.opacity = '1';

            if (funnyMessageTimeout) {
                clearTimeout(funnyMessageTimeout);
            }

            funnyMessageTimeout = setTimeout(() => {
                funnyMessage.style.opacity = '0';
            }, 3000);
        }

        // Ship3 (controlled by WASD keys)
        const wasdKeys = { w: false, s: false, a: false, d: false };

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW') wasdKeys.w = true;
            if (e.code === 'KeyS') wasdKeys.s = true;
            if (e.code === 'KeyA') wasdKeys.a = true;
            if (e.code === 'KeyD') wasdKeys.d = true;
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') wasdKeys.w = false;
            if (e.code === 'KeyS') wasdKeys.s = false;
            if (e.code === 'KeyA') wasdKeys.a = false;
            if (e.code === 'KeyD') wasdKeys.d = false;
        });

        function controlShip3() {
            const speed = 2;
            let velocity = { x: 0, y: 0 };

            if (wasdKeys.w) velocity.y -= speed;
            if (wasdKeys.s) velocity.y += speed;
            if (wasdKeys.a) velocity.x -= speed;
            if (wasdKeys.d) velocity.x += speed;

            Body.setVelocity(ship3, velocity);
        }

        let gravityCollectorPurchased = false;
        let gravityCollectorStrength = 1;

        function removeSortedCircles(numToRemove) {
            let removedCount = 0;
            totalMoneySpent += numToRemove;

            for (let i = circles.length - 1; i >= 0 && removedCount < numToRemove; i--) {
                if (isCircleInCorrectArea(circles[i])) {
                    const circle = circles[i];
                    circle.isTargeted = false;
                    const circlePosition = { x: circle.position.x, y: circle.position.y };
                    const circleColor = circle.render.fillStyle;

                    World.remove(world, circle);
                    circles.splice(i, 1);
                    removedCount++;

                    // Create a "ghost" circle for the visual effect
                    const ghostCircle = Bodies.circle(circlePosition.x, circlePosition.y, circle.circleRadius * 1.2, {
                        isStatic: true,
                        collisionFilter: {
                            group: -1,
                            category: 0x0001,
                            mask: 0x0000
                        },
                        render: {
                            fillStyle: circleColor,
                            opacity: 1
                        }
                    });

                    World.add(world, ghostCircle);

                    let fadeInterval = setInterval(() => {
                        ghostCircle.circleRadius *= 0.9;
                        ghostCircle.render.opacity *= 0.9;
                        if (ghostCircle.circleRadius < 1 || ghostCircle.render.opacity < 0.1) {
                            World.remove(world, ghostCircle);
                            clearInterval(fadeInterval);
                        }
                    }, 200);
                }
            }
        }

        function addRedRings() {
            const ringOptions = {
                isStatic: true,
                render: {
                    fillStyle: 'transparent',
                    strokeStyle: 'rgba(255, 0, 0, 0.3)', // Faint red color with 30% opacity
                    lineWidth: 5,
                    opacity: 1
                },
                collisionFilter: {
                    group: -1, // Ensure it does not collide with anything
                    category: 0x0001,
                    mask: 0x0000 // No collisions with other objects
                }
            };

            // Define the radius of the rings
            const ringRadius = 150; // Adjust as needed for visual effect

            // Create and add rings for each target position
            for (let key in targetPositions) {
                const pos = targetPositions[key];
                const ring = Bodies.circle(pos.x, pos.y, ringRadius, ringOptions);
                World.add(world, ring);
            }
        }

        function activateGravityCollector() {
            removeSortedCircles(50);
            if (gravityCollectorPurchased) {
                gravityCollectorStrength += 1;
                document.getElementById("buy-gravity-collector").innerHTML = `Upgrade Gravity Collector to level ${gravityCollectorStrength + 1} (cost 50)`;
                return;
            }
            gravityCollectorPurchased = true;
            document.getElementById("buy-gravity-collector").innerHTML = `Upgrade Gravity Collector to level ${gravityCollectorStrength + 1} (cost 50)`;
            addRedRings()
            Events.on(engine, 'beforeUpdate', function () {
                if (gravityCollectorPurchased) {
                    circles.forEach(circle => {
                        if (!isCircleInCorrectArea(circle, tolerance_starting = 100)) {
                            const material = materials.find(m => m.color === circle.render.fillStyle);
                            const target = targetPositions[material.name];
                            const angle = Math.atan2(target.y - circle.position.y, target.x - circle.position.x);

                            Body.applyForce(circle, circle.position, {
                                x: 0.0000005 * gravityCollectorStrength * Math.cos(angle),
                                y: 0.0000005 * gravityCollectorStrength * Math.sin(angle)
                            });
                        }
                    });
                }
            });
        }

        // Start the game loop
        let gameStarted = true;
        startTime = new Date();

        (function run() {
            window.requestAnimationFrame(run);
            if (gameStarted) {
                Engine.update(engine, 1000 / 60);
                controlShip3();
                updateAutomation();
                checkWinCondition();
            }
        })();

        // JS for toggling admin panel
        const adminToggleButton = document.getElementById('admin-panel-toggle');
        const adminPanel = document.getElementById('admin-panel');

        // Add a click event listener to the toggle button
        adminToggleButton.addEventListener('click', () => {
            // Toggle the 'collapsed' class on the admin panel
            adminPanel.classList.toggle('collapsed');
        });

        // Handle window resize to maintain scaling
        window.addEventListener('resize', () => {
            scaleX = window.innerWidth / GAME_WIDTH;
            scaleY = window.innerHeight / GAME_HEIGHT;
            scale = Math.min(scaleX, scaleY);

            render.options.width = GAME_WIDTH * scale;
            render.options.height = GAME_HEIGHT * scale;

            render.canvas.style.width = `${GAME_WIDTH * scale}px`;
            render.canvas.style.height = `${GAME_HEIGHT * scale}px`;

            render.bounds.max.x = GAME_WIDTH;
            render.bounds.max.y = GAME_HEIGHT;
            render.bounds.min.x = 0;
            render.bounds.min.y = 0;

            render.options.pixelRatio = 1 / scale;
            Render.setPixelRatio(render, 1 / scale);
        });

    </script>
</body>

</html>
